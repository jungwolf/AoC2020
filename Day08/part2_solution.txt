create or replace view day08_part2_ops as
  select lineno, substr(xline,1,3) op, to_number(substr(xline,5)) arg from day08_data;
select * from day08_part2_ops;

create or replace view day08_part2_programs as
select
    linenob prognum
  , linenoa lineno 
  , decode( opa||linenoa,opb||linenob -- if the line and op are the same...
      ,decode(opa,'nop','jmp','jmp','nop') -- switch them
      ,opa)   -- otherwise keep it the same
    op
  , arga arg 
from (
  select a.lineno linenoa, a.op opa, a.arg arga, b.lineno linenob, b.op opb, b.arg argb
  from day08_part2_ops a, day08_part2_ops b
  where b.op in ('jmp','nop')
)
/

-- get rid of the hard coded nextline
select reg1 from (
select level, prognum, lineno, op, arg, nextline, sum(decode(op,'acc',arg,0)) over (partition by prognum order by level) reg1 from (
  select prognum, lineno, op, arg, decode(op,'jmp',lineno+arg,lineno+1) nextline from (
    select prognum, lineno, op, arg from day08_part2_programs
  )
)
connect by nocycle prior nextline=lineno and prior prognum = prognum start with lineno = 1
)
where nextline = where nextline = (select count(*)+1 from day08_data);

