-- assume input is in table day08_data as (line number in text file), (raw text string)
--   fields (lineno, xline)
-- solution first, detailed explaination second
-- I decided to use views to make things a little easier to understand (and to save my sanity)

-- parsed view of the original raw file
--  op (operation), arg (argument), and I keep lineno to use in gotos
create or replace view day08_part2_ops as
select 
  lineno                           -- GOTO from BASIC!!
  , substr(xline,1,3) op           -- operation
  , to_number(substr(xline,5)) arg -- argument to the operation
from day08_data;

create or replace view day08_part2_programs as
select
    linenob prognum
  , linenoa lineno 
  , decode( opa||linenoa, opb||linenob        -- if the line and op are the same...
      ,decode(opa, 'nop','jmp', 'jmp','nop' ) -- switch them
      ,opa                                   -- otherwise keep it the same
    ) op
  , arga arg 
from (
  select a.lineno linenoa, a.op opa, a.arg arga, b.lineno linenob, b.op opb, b.arg argb
  from day08_part2_ops a, day08_part2_ops b
  where b.op in ('jmp','nop')
)
/

select reg1
from (
  select level
    , prognum
    , lineno
    , op
    , arg
    , nextline
    , sum(decode(op,'acc',arg,0)) over (partition by prognum order by level) reg1
  from (
    select prognum, lineno, op, arg
      , decode(op,'jmp',lineno+arg,lineno+1) nextline
    from (
      select prognum, lineno, op, arg from day08_part2_programs
    )
  )
  connect by nocycle prior nextline=lineno and prior prognum = prognum start with lineno = 1
)
where nextline = (select count(*)+1 from day08_data);

