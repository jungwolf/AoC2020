-- game of life with cubes
-- consider the current state to determine the next state
-- a cube has 26 neighbors, off-by-one in x,y,and/or z.
-- if cube is active, 2 or 3 active neighbors -> active, otherwise -> inactive
-- if cube is inactive, 3 active neighbors -> active, otherwise -> inactive

-- I think, this time, only keep track of active cubes.
-- for each active cube, add 1 to count of neighbors to all neighbor cubes
-- once complete, sweep through all potential cubes and follow a+2|3n -> a, i+3a ->a, otherwise i
/*
current list of active cubes, active, full of points (x,y,z)
generate list of potentially active cubes, potential, by looping through active and insert/update neighbors by +1
generate new list of active cubes by looping through potential and following aliveness rules
redo
*/
-- cubes(x,y,z)
-- potential (x,y,z,num,active)

/*
z=0 at first
# -> active
      x
 |   -1  0 +1
-+-----------
y|-1  .  #  .
 | 0  .  .  #
 |+1  #  #  #
*/
-- only insert active cubes; existence -> active
create table day17_cubes (x number, y number, z number);
insert into day17_cubes values (-1, 1, 0);
insert into day17_cubes values ( 0,-1, 0);
insert into day17_cubes values ( 0, 1, 0);
insert into day17_cubes values ( 1, 0, 0);
insert into day17_cubes values ( 1, 1, 0);
commit;




merge into potential p
 Using (
   Select c.x+inx.o, c.y+iny.o, c.z+iny.z
   From cubes c, offset inx, offset iny, offset inx
   Where inx.o != iny.o and inty.o != intz.o) z
 On (p.x=z.x and p.y=z.y and p.z=z.z)
 When matched then update set p.n=p.n+1
 ..not.. then insert (x,y,z,n,active)
     Values (z.x,z.y,z.z,0,false);
